#pragma once

const char calc_binary_states[] = 
	"#version 330\n"
	"uniform usampler2DRect random;\n"
	"uniform sampler2DRect probabilities;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float state;\n"
	"void main()\n"
	"{\n"
	" uint next_int = texture(random, tex_coordinate).x;\n"
	" float prob = texture(probabilities, tex_coordinate).x;\n"
	" if(uint(prob * 4294967296.0) > next_int)\n"
	"  state = 1.0;\n"
	" else\n"
	"  state = 0.0;\n"
	"}\n";

const char calc_copy_texture[] = 
	"#version 330\n"
	"uniform sampler2DRect source;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float value;\n"
	"void main()\n"
	"{\n"
	" value = texture(source, tex_coordinate).x;\n"
	"}\n";

const char calc_depthmap[] = 
	"#version 330\n"
	"uniform sampler2DRect enabled_rows;\n"
	"uniform sampler2DRect enabled_columns;\n"
	"uniform sampler2DRect prev_vals;\n"
	"uniform int check_rows;\n"
	"uniform int check_columns;\n"
	"uniform int use_prev_vals;\n"
	"uniform vec2 offset;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float value;\n"
	"void main()\n"
	"{\n"
	" // this pixel should be disabled\n"
	" if ((check_rows == 1 && texture(enabled_rows, vec2(tex_coordinate.y - offset.y, 0.5)).x == 0.0)\n"
	" ||  (check_columns == 1 && texture(enabled_columns, vec2(tex_coordinate.x - offset.x, 0.5)).x == 0.0))\n"
	" {\n"
	"  if(use_prev_vals == 1)\n"
	"  {\n"
	"   value = texture(prev_vals, tex_coordinate).x;\n"
	"  }\n"
	"  else\n"
	"  {\n"
	"   value = 0.0;\n"
	"  }\n"
	" }\n"
	" // this pixel should be enabled\n"
	" else\n"
	" {\n"
	"  discard;\n"
	" }\n"
	"}\n";

const char calc_enabled_unit[] = 
	"#version 330\n"
	"uniform usampler2DRect random;\n"
	"uniform float probability;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float state;\n"
	"void main()\n"
	"{\n"
	" uint next_int = texture(random, tex_coordinate).x;\n"
	" if(uint(probability * 4294967296.0) > next_int)\n"
	"  state = 1.0;\n"
	" else\n"
	"  state = 0.0;\n"
	"}\n";

const char calc_error_vector[] = 
	"#version 330\n"
	"uniform sampler2DRect visible;\n"
	"uniform sampler2DRect visible_reconstruction;\n"
	"uniform int minibatch_size;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float mean_square_error;\n"
	"void main()\n"
	"{\n"
	" mean_square_error = 0.0;\n"
	" for(int k = 0; k < minibatch_size; k++)\n"
	" {\n"
	"  float v = texture(visible, vec2(tex_coordinate.x, float(k) + 0.5)).x;\n"
	"  float v_prime = texture(visible_reconstruction, vec2(tex_coordinate.x, float(k) + 0.5)).x;\n"
	"  float diff = v - v_prime;\n"
	"  mean_square_error += diff*diff;\n"
	" }\n"
	" mean_square_error /= float(minibatch_size);\n"
	"}\n";

const char calc_hidden_probabilities[] = 
	"#version 330\n"
	"// input textures\n"
	"uniform sampler2DRect visible_states;\n"
	"uniform sampler2DRect rbm_weights;\n"
	"uniform int visible_units;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float probability;\n"
	"// matrix coordinates\n"
	"//x == j\n"
	"//y == i\n"
	"void main()\n"
	"{\n"
	" // bias\n"
	" probability = texture(rbm_weights, vec2(tex_coordinate.x + 1.0, 0.5)).x;\n"
	" for(int i = 0; i <  visible_units; i++)\n"
	" {\n"
	"  float v_i = texture(visible_states, vec2(float(i) + 0.5, tex_coordinate.y)).x;\n"
	"  float w_ij = texture(rbm_weights, vec2(tex_coordinate.x + 1.0, float(i) + 1.5)).x;\n"
	"  probability += v_i * w_ij;\n"
	" }\n"
	" probability = 1.0 / (1.0 + exp(-probability));\n"
	"}\n";

const char calc_new_weights[] = 
	"#version 330\n"
	"uniform sampler2DRect prev_weights;\n"
	"uniform sampler2DRect delta_weights;\n"
	"// conversion factors so updates are weights * learning_rate sized\n"
	"uniform float weight_factor;\n"
	"uniform float hidden_factor;\n"
	"uniform float visible_factor;\n"
	"uniform float learning_rate;\n"
	"// regularization values\n"
	"uniform float l1_regularization;\n"
	"uniform float l2_regularization;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float new_weight;\n"
	"void main()\n"
	"{\n"
	" uint i = uint(tex_coordinate.y);\n"
	" uint j = uint(tex_coordinate.x);\n"
	" float delta = texture(delta_weights, tex_coordinate).x;\n"
	" float prev = texture(prev_weights, tex_coordinate).x;\n"
	" float factor;\n"
	" if(i == 0u && j == 0u)\n"
	" {\n"
	"  new_weight = 0.0;\n"
	"  return;\n"
	" }\n"
	" else if(i == 0u)\n"
	" {\n"
	"  factor = hidden_factor;\n"
	" }\n"
	" else if(j == 0u)\n"
	" {\n"
	"  factor = visible_factor;\n"
	" }\n"
	" else\n"
	" {\n"
	"  factor = weight_factor;\n"
	"  float l1 = l1_regularization * sign(prev);\n"
	"  float l2 = l2_regularization * prev;\n"
	"  delta -= (l1 + l2);\n"
	" }\n"
	" // add weight deltas\n"
	" new_weight = prev + (factor * learning_rate * delta);\n"
	"}\n";

const char calc_random[] = 
	"#version 330\n"
	"// calculate next values using Numerical recipes LCRG:\n"
	"// http://en.wikipedia.org/wiki/Linear_congruential_generator\n"
	"const uint a = 1664525u;\n"
	"const uint c = 1013904223u;\n"
	"uniform usampler2DRect seeds;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out uint next_int;\n"
	"void main()\n"
	"{\n"
	" next_int = texture(seeds, tex_coordinate).x * a + c;\n"
	"}\n";

const char calc_texture_coordinates[] = 
	"#version 330\n"
	"// calculate the texture coordinates\n"
	"layout (location = 0) in vec2 position;\n"
	"// viewport size\n"
	"uniform vec2 size;\n"
	"uniform float depth;\n"
	"smooth out vec2 tex_coordinate;\n"
	"void main(void)\n"
	"{\n"
	" gl_Position.xy = 2.0 * (position / size) - vec2(1.0, 1.0);\n"
	" gl_Position.z = depth;\n"
	" gl_Position.w =  1.0;\n"
	" tex_coordinate = position;\n"
	"}\n";

const char calc_visible_reconstructions[] = 
	"#version 330\n"
	"// input textures\n"
	"uniform sampler2DRect hidden_states;\n"
	"uniform sampler2DRect rbm_weights;\n"
	"uniform int hidden_units;\n"
	"uniform bool sigmoid;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float reconstruction;\n"
	"// matrix coordinates\n"
	"//x == j\n"
	"//y == i\n"
	"void main()\n"
	"{\n"
	" // bias\n"
	" reconstruction = texture(rbm_weights, vec2(0.5, tex_coordinate.x + 1.0)).x;\n"
	" for(int j = 0; j <  hidden_units; j++)\n"
	" {\n"
	"  float h_j = texture(hidden_states, vec2(float(j) + 0.5, tex_coordinate.y)).x;\n"
	"  float w_ij = texture(rbm_weights, vec2(float(j) + 1.5, tex_coordinate.x + 1.0)).x;\n"
	"  reconstruction += h_j * w_ij;\n"
	" }\n"
	" // sigmoid\n"
	" if(sigmoid)\n"
	"  reconstruction = 1.0 / (1.0 + exp(-reconstruction));\n"
	"}\n";

const char calc_weight_deltas[] = 
	"#version 330\n"
	"// textures\n"
	"uniform sampler2DRect visible;\n"
	"uniform sampler2DRect hidden;\n"
	"uniform sampler2DRect visible_prime;\n"
	"uniform sampler2DRect hidden_prime;\n"
	"uniform sampler2DRect prev_weight_deltas;\n"
	"uniform sampler2DRect prev_weights;\n"
	"// training parameters\n"
	"uniform float momentum;\n"
	"uniform int minibatch_size;\n"
	"smooth in vec2 tex_coordinate;\n"
	"out float delta;\n"
	"void main()\n"
	"{\n"
	" delta = 0.0;\n"
	" uint i = uint(tex_coordinate.y);\n"
	" uint j = uint(tex_coordinate.x);\n"
	" float vi, vi_prime;\n"
	" float hj, hj_prime;\n"
	" if(i == 0u && j == 0u)\n"
	" {\n"
	"  return;\n"
	" }\n"
	" // hidden bias\n"
	" else if(i == 0u)\n"
	" {\n"
	"  for(int k = 0; k  < minibatch_size; k++)\n"
	"  {\n"
	"   hj = texture(hidden, vec2(tex_coordinate.x - 1.0, float(k) + 0.5)).x;\n"
	"   hj_prime = texture(hidden_prime, vec2(tex_coordinate.x - 1.0, float(k) + 0.5)).x;\n"
	"   delta += hj - hj_prime;\n"
	"  }\n"
	"  delta /=  float(minibatch_size);\n"
	" }\n"
	" // visible bias\n"
	" else if(j == 0u)\n"
	" {\n"
	"  for(int k = 0; k  < minibatch_size; k++)\n"
	"  {\n"
	"   vi = texture(visible, vec2(tex_coordinate.y - 1.0, float(k) + 0.5)).x;\n"
	"   vi_prime = texture(visible_prime, vec2(tex_coordinate.y - 1.0, float(k) + 0.5)).x;\n"
	"   delta += vi - vi_prime;\n"
	"  }\n"
	"  delta /= float(minibatch_size);\n"
	" }\n"
	" // regular weight\n"
	" else\n"
	" {\n"
	"  for(int k = 0; k  < minibatch_size; k++)\n"
	"  {\n"
	"   vi = texture(visible, vec2(tex_coordinate.y - 1.0, float(k) + 0.5)).x;\n"
	"   vi_prime = texture(visible_prime, vec2(tex_coordinate.y - 1.0, float(k) + 0.5)).x;\n"
	"   hj = texture(hidden, vec2(tex_coordinate.x - 1.0, float(k) + 0.5)).x;\n"
	"   hj_prime = texture(hidden_prime, vec2(tex_coordinate.x - 1.0, float(k) + 0.5)).x;\n"
	"   delta += vi * hj - vi_prime * hj_prime;\n"
	"  }\n"
	"  delta /= float(minibatch_size);\n"
	" }\n"
	" delta = (1.0 - momentum) * delta + momentum * texture(prev_weight_deltas, tex_coordinate).x;\n"
	"}\n";

